---
title: "Generate a synthetic Time Series with make_AR()"
author: "Alexander Klaus"
output: pdf_document
vignette: >
  %\VignetteIndexEntry{make_AR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, make_AR() setup, include = FALSE}
library(zeitreihen)

set.seed(742)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE,
  fig.height = 6,
  fig.width = 6,
  tidy = TRUE
)
```

## Autoregressive process `make_AR()`
The `make_AR()` function generates a synthetic time series following an AR(p) (Autoregressive of order p) model. This function allows you to create time series data based on specified AR coefficients and white noise variance.

### Basic Usage
Specify the length of the desired time series using `t`, set the coefficients of the AR(p) process as `phi`.
```{r, make_AR() basic usage}
library(zeitreihen)
t <- 100
phi <- 0.5

make_AR(t, phi)
```
The output, is time series that follows the AR(p) model. \
The output is a numeric or complex atomic vector of length `t` containing data generated by the AR model with hand over parameter. The output values corresponds to the sequential observations from 1 to `t`.
\

What is happening inside the function:

* It is checked within the function whether the inputs are in the correct format.
* An atomic vector \(X\) of length `t` is created. If a vector `start` is passed, `X` contains this vector as values of the first `length(start)` entries.
* `t` normally distributed values with mean 0 and standard deviation `sigma` are generated.
* Iterative calculation of \(X\) from `p + 1` to `t` with loop variable i:
    * Consider the vector, which stores the values from \(X_{i - 1} \dots X_{i - q}\).
    * The dot product of the vector mentioned above, and the vector phi is then calculated.
    * \(Z[i]\) is added to the dot product.
    * And the previous calculation is stored in X[i].
* Finally, the values are returned.
\

Required Format:

* `t` must be a positive integer of length 1, where NA, Inf or NaN aren't allowed.
* `t` has to be bigger than the length of `phi`
* `phi` must a be non-empty numeric/complex vector
* `phi` is not allowed to contain NA, INF or NaN values.
* `sigma` must be a non-zero and positive numeric vector of length equal to 1, where NA, Inf or NaN are not allowed.

### Using complex numbers
```{r, make_AR() complex numbers}
t <- 10
phi <- complex(real = 1, imaginary = 2)
sigma <- 1

make_AR(t, phi, sigma)
```
Note: `make_AR` supports numeric or complex atomic vectors for `phi`.

### Using large Output
```{r, make_AR() large output}
t <- 40
phi <- 3
sigma <- 1

make_AR(t, phi, sigma)
```
Calling the `make_AR`, where `sigma` is omitted is allowed. Within `make_AR` we use `1` as default value for `sigma`. \
Note: The Output will get big so mind to generate only the number of observation that are needed.

### Requirements
If the input does not correspond to the correct format, appropriate error messages are printed to inform the user what is wrong with their input. Here are several examples of how incorrect inputs are handled. \
The values of phi must be passed in an atomic vector:
```{r, make_AR() phi error (format), error = TRUE}
t <- 10
phi <- list(1, 2, 3, 4, 5)
sigma <- 1

make_AR(t, phi, sigma)
```

The values of this atomic vector must be numeric or complex:
```{r, make_AR() phi error (value format), error = TRUE}
t <- 10
phi <- "L"
sigma <- 1

make_AR(t, phi, sigma)
```

The integer `t` must be greater than the length of phi:
```{r, make_AR() phi error (length), error = TRUE}
t <- 2
phi <- c(1, 2)
sigma <- 1

make_AR(t, phi, sigma)
```

Sigma must be a positive numeric value:
```{r, make_AR() sigma error (value), error = TRUE}
t <- 10
phi <- 1
sigma <- 0

make_AR(t, phi, sigma)
```
