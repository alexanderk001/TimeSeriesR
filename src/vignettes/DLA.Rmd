---
title: "DLA"
author: "Clemens Glomb"
output: pdf_document
vignette: >
  %\VignetteIndexEntry{DLA}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
library(devtools)
load_all(".")
knitr::opts_chunk$set(echo = TRUE)
```

## Durbin-Levinson Algorithm
### Introduction

The Durbin-Levinson Algorithm is a recursive method applied to stationary time series \(\{X_t\}\) for the efficient calculation of autoregressive coefficients in AR(p) processes. The algorithm provides the coefficients needed for one-step predictors \(\hat{X}_1, \hat{X}_2, \dots\) and can be computed recursively. Additionally, it allows for modeling time series to make predictions and understand the series' movement over time.

### Practical Application
#### **Simple Example**:
  
  To apply the algorithm to a time series X, we call the function `DLA()` with parameter X. Every time we call upon the algorithm, a warning will be given that the user has to check if the time series is stationary.
  
```{r}
set.seed(1)
X <- stats::rnorm(5, mean = 0, sd = 1)
cat("The time series: ", X, "\n")
model <- DLA(X)
```
  
We use the `DLA` function from the `zeitreihen` package to calculate the coefficients `phi` and the mean squared errors `v` for this time series, focusing on `m = 2`. The `DLA` function returns an anonymous function that takes `m` as a parameter, where `m` represents the number of past values used to predict the next value of the time series using the Durbin-Levinson algorithm. This function calculates the necessary coefficients and mean squared errors, returning a list with two components: `phi` (the coefficients) and `v` (the mean squared errors).


```{r}
model(2)
```

##### Output Interpretation:
- **Coefficients (`phi`)**: `[1] -0.30716625  0.06567492`
   - **-0.30716625**: First AR coefficient \(\phi_{11}\), indicating a -0.307 influence from the previous value.
   - **0.06567492**: Second AR coefficient \(\phi_{12}\), indicating a 0.065 influence from the value two steps back.

- **Mean Squared Errors (`v`)**: `[1] 0.7388774 0.6590185 0.65617601`
   - **0.7388774**: Mean squared error at step 1, indicating prediction uncertainty.
   - **0.6590185**: Mean squared error at step 2, suggesting slightly more reliable predictions compared to step 1.
   - **0.65617601**: Mean squared error at step 3, showing that prediction errors continue to decrease and stabilize.

Here’s what happens step by step:

1. **Start**: The algorithm begins by calculating the first coefficient \(\phi_{11}\). This is computed as \(\gamma(1) / \gamma(0)\), where \(\gamma(1)\) is the autocovariance at lag 1, and \(\gamma(0)\) is the variance of the time series.

2. **Recursive Calculation**: For each step \(n\), the algorithm calculates the coefficient \(\phi_{nn}\) by adjusting the autocovariance \(\gamma(n)\). This adjustment is based on the previous coefficients \(\phi_{n-1,j}\) and the autocovariances \(\gamma(n-j)\).

3. **Matrix Update**: The coefficients \(\phi_{n-1,1}\) through \(\phi_{n-1,n-1}\) are updated, and the new value \(\phi_{nn}\) is added. This is necessary to compute the next set of coefficients.

4. **Mean Squared Errors**: The mean squared error \(v_n\) is calculated at each step to capture the uncertainty in the estimates. This variance is based on the previous variance \(v_{n-1}\) and the current coefficient \(\phi_{nn}\).

5. **Results**: At the end, the algorithm returns two vectors: `phi`, containing the calculated coefficients, and `v`, containing the mean squared errors. These values are important for modeling and forecasting time series data.


#### Example 2: Big Example:
  Let’s work with the following time series data:

```{r}
set.seed(2)
X <- stats::rnorm(100, mean = 0, sd = 1)
model <- DLA(X)
result <- model(5)
print(result)
```

### Example 3: Incorrect inputs

If the input do not correspond to the correct format, appropriate error messages are printed to inform the user what is wrong with their input. Here are several examples of how incorrect inputs are handled:

The time series data X must be passed in an atomic vector:

```{r error=TRUE}
X <- list(1, 2, 3, 4, 5)
model <- DLA(X)
```

Also, the values of X must be numeric or complex:

```{r, error=TRUE}
X <- c(1, 2, "3", 4, "5i")
model <- DLA(X)
```

In addition, the atomic vector may not contain any NAs:

```{r, error=TRUE}
X <- c(1, NA, 2, 3, 4)
model <- DLA(X)
```

The atomic vector may not contain Inf or -Inf values:

```{r, error=TRUE}
X <- c(1, 2, Inf, 3, 4)
model <- DLA(X)
```

The m paramter must be a value of length 1:

```{r, error=TRUE, warning=FALSE}
X <- rnorm(100)
model <- DLA(X)
result <- model(c(1,2))
```

The m parameter must be an integer value between 0 and the length of X:

```{r, error=TRUE, warning=FALSE}
X <- rnorm(100)
model <- DLA(X)
result <- model(101)
```

### References
If you need more information, please refer to the package documentation or the following resources:

- [Introduction to Time Series and Forecasting](https://link.springer.com/book/10.1007/978-3-319-29854-2)

