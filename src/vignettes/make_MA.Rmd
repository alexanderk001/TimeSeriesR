---
title: "Generate a synthetic Time Series with make_MA()"
author: "Sebastian Meier"
output: pdf_document
vignette: >
  %\VignetteIndexEntry{make_MA}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, make_MA() setup, include = FALSE}
library(zeitreihen)

set.seed(742)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE,
  fig.height = 6,
  fig.width = 6,
  tidy = TRUE
)
```

## Moving-average process `make_MA()`
The function `make_MA` generates synthetic time series based on MA(q) (Moving-average of order q) model. By Providing the MA coefficients and white noise standard deviation to the `make_MA` function, data for a time series can be created.

### Basic Usage
First, specify the length of the time series `t`. Next, specify `theta`, which contains the MA coefficients, where `t` must be bigger than the sum of all \(theta_i\) in `theta`.
```{r, make_MA() basic usage}
t <- 10
theta <- 1

make_MA(t, theta)
```
The output, is time series that follows the MA(q) model. \
The output is a numeric or complex atomic vector of length `t` containing data generated by the MA model with hand over parameter. The output values corresponds to the sequential observations from 1 to `t`.
\

What is happening inside the function:

* Within the function, it is checked if `t`, `theta` and `sigma` have the required format.
* \(q\) is derived by the length of `theta`.
* Allocation of a numeric vector \(X\) of length `t` to store the time series data.
* By providing `sigma`, we allocate `t + q` instances of white noise in `Z`.
* Computation of \(X\) iteratively from \(q + 1\) to \(t + q\) with loop variable i:
  * Consider the vector, which stores the values from \(Z_{i - 1} \dots Z_{i - q}\).
  * The dot product of the vector mentioned above, and the vector theta is then calculated.
  * \(Z_i\) is added to the dot product.
  * And the previous calculation is stored in \(X[i - q]\).
* Finally, the values are returned.
\

Required Format:

* `t` must be a positive integer of length 1, where NA, Inf or NaN aren't allowed.
* `t` has to be bigger than the length of `theta`
* `theta` must a be non-empty numeric/complex vector
* `theta` is not allowed to contain NA, INF or NaN values.
* `sigma` must be a non-zero and positive numeric vector of length equal to 1, where NA, Inf or NaN are not allowed.

### Using complex numbers
```{r, make_MA() complex numbers}
t <- 10
theta <- complex(real = 1, imaginary = 2)
sigma <- 1

make_MA(t, theta, sigma)
```
Note: `make_MA` supports numeric or complex vector for `theta`.

### Generating larger output
```{r, make_MA() large output}
t <- 100
theta <- 3
sigma <- 1

make_MA(t, theta, sigma)
```
Calling the `make_MA`, where `sigma` is omitted, is allowed. Within `make_MA` we use `1` as a value for `sigma`. \
Note: The Output will get big, so mind to generate only the amount observation that are needed.

### Requirements
If the input does not correspond to the correct format, appropriate error messages are printed to inform the user what is wrong with their input. Here are several examples of how incorrect inputs are handled. \
The values of theta must be passed in an atomic vector:
```{r, make_MA() theta error (format), error = TRUE}
t <- 10
theta <- list(1, 2, 3, 4, 5)
sigma <- 0

make_MA(t, theta, sigma)
```

The values of this atomic vector must be numeric or complex:
```{r, make_MA() theta error (value format), error = TRUE}
t <- 10
theta <- "L"
sigma <- 1

make_MA(t, theta, sigma)
```

The integer `t` must be greater than the length of phi:
```{r, make_MA() theta error (length), error = TRUE}
t <- 2
theta <- c(1, 2)
sigma <- 1

make_MA(t, theta, sigma)
```

Sigma must be a positive numeric value:
```{r, make_MA() sigma error (value), error = TRUE}
t <- 2
theta <- 1
sigma <- 1

make_MA(t, theta, sigma)
```
